// @if feat.babel
import gulp from 'gulp';
import minimatch from 'minimatch';
import gulpWatch from 'gulp-watch';
import debounce from 'debounce';
import project from '../aurelia.json';
// @endif
// @if feat.typescript
import * as gulp from 'gulp';
import * as minimatch from 'minimatch';
import * as gulpWatch from 'gulp-watch';
import * as debounce from 'debounce';
import * as project from '../aurelia.json';
// @endif
// @if feat.plugin
import { buildPluginJavaScript } from './transpile';
import { pluginMarkup } from './process-markup';
import { pluginCSS } from './process-css';
import { pluginJson } from './process-json';
// @endif
// @if !feat.plugin
import transpile from './transpile';
import processMarkup from './process-markup';
import processCSS from './process-css';
import processJson from './process-json';
import copyFiles from './copy-files';
// @endif
import { build } from 'aurelia-cli';

const debounceWaitTime = 100;
let isBuilding = false;
let pendingRefreshPaths = [];
let watchCallback = () => { };
// @if feat.plugin
function processMarkupPlugin() {
  return gulp.parallel(
    pluginMarkup('dist/native-modules'),
    pluginMarkup('dist/commonjs')
  )
}

function processCSSPlugin() {
  return gulp.parallel(
    pluginCSS('dist/native-modules'),
    pluginCSS('dist/commonjs')
  )
}

function processJsonPlugin() {
  return gulp.parallel(
    pluginJson('dist/native-modules'),
    pluginJson('dist/commonjs')
  )
}

function transpilePlugin() {
  return gulp.parallel(
    buildPluginJavaScript('dist/native-modules', 'es2015'),
    buildPluginJavaScript('dist/commonjs', 'commonjs')
  );
}

let watches = [
  { name: 'transpile', callback: transpilePlugin(), source: project.transpiler.source },
  { name: 'markup', callback: processMarkupPlugin(), source: project.markupProcessor.source },
  { name: 'CSS', callback: processCSSPlugin(), source: project.cssProcessor.source },
  { name: 'JSON', callback: processJsonPlugin(), source: project.jsonProcessor.source }
];
// @endif
// @if !feat.plugin
let watches = [
  { name: 'transpile', callback: transpile, source: project.transpiler.source },
  { name: 'markup', callback: processMarkup, source: project.markupProcessor.source },
  { name: 'CSS', callback: processCSS, source: project.cssProcessor.source },
  { name: 'JSON', callback: processJson, source: project.jsonProcessor.source }
];

if (typeof project.build.copyFiles === 'object') {
  for (let src of Object.keys(project.build.copyFiles)) {
    watches.push({ name: 'file copy', callback: copyFiles, source: src });
  }
}
// @endif

let watch = (callback) => {
  watchCallback = callback || watchCallback;

  // watch every glob individually
  for(let watcher of watches) {
    if (Array.isArray(watcher.source)) {
      for(let glob of watcher.source) {
        watchPath(glob);
      }
    } else {
      watchPath(watcher.source);
    }
  }
};

let watchPath = (p) => {
  gulpWatch(
    p,
    {
      read: false, // performance optimization: do not read actual file contents
      verbose: true
    },
    (vinyl) => processChange(vinyl));
};

let processChange = (vinyl) => {
  if (vinyl.path && vinyl.cwd && vinyl.path.startsWith(vinyl.cwd)) {
    let pathToAdd = vinyl.path.slice(vinyl.cwd.length + 1);
    log(`Watcher: Adding path ${pathToAdd} to pending build changes...`);
    pendingRefreshPaths.push(pathToAdd);
    refresh();
  }
}

let refresh = debounce(() => {
  if (isBuilding) {
    log('Watcher: A build is already in progress, deferring change detection...');
    return;
  }

  isBuilding = true;

  let paths = pendingRefreshPaths.splice(0);
  let refreshTasks = [];

  // determine which tasks need to be executed
  // based on the files that have changed
  for (let watcher of watches) {
    if (Array.isArray(watcher.source)) {
      for(let source of watcher.source) {
        if (paths.find(path => minimatch(path, source))) {
          refreshTasks.push(watcher);
        }
      }
    }
    else {
      if (paths.find(path => minimatch(path, watcher.source))) {
        refreshTasks.push(watcher);
      }
    }
  }

  if (refreshTasks.length === 0) {
    log('Watcher: No relevant changes found, skipping next build.');
    isBuilding = false;
    return;
  }

  log(`Watcher: Running ${refreshTasks.map(x => x.name).join(', ')} tasks on next build...`);

// @if feat.plugin
  let toExecute = gulp.series(
    gulp.parallel(refreshTasks.map(x => x.callback)),
    (done) => {
      isBuilding = false;
      watchCallback();
      done();
      if (pendingRefreshPaths.length > 0) {
        log('Watcher: Found more pending changes after finishing build, triggering next one...');
        refresh();
      }
    }
  );
  
  toExecute();
}, debounceWaitTime);
// @endif
// @if !feat.plugin
  let toExecute = gulp.series(
    readProjectConfiguration,
    gulp.parallel(refreshTasks.map(x => x.callback)),
    writeBundles,
    (done) => {
      isBuilding = false;
      watchCallback();
      done();
      if (pendingRefreshPaths.length > 0) {
        log('Watcher: Found more pending changes after finishing build, triggering next one...');
        refresh();
      }
    }
  );

  toExecute();
}, debounceWaitTime);

function readProjectConfiguration() {
  return build.src(project);
}

function writeBundles() {
  return build.dest();
}
// @endif

function log(message/* @if feat.typescript **: string/* @endif */) {
  console.log(message);
}

export default watch;
